package schema

import (
	"gopkg.in/yaml.v3"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

type Action string
type Generation string

const (
	ActionGenerate Action = "generate" // Generate list of values for insert to db
	ActionGet      Action = "get"      // Get list of values from db

	GenerationTypeDb    Generation = "db"      // Data will be generated by DB for example auto_increment and so on
	GenerationTypeFaker Generation = "faker"   // Generate fake data
	GenerationTypeList  Generation = "list"    // Get data from defined list (property List of Field struct)
	GenerationDepends   Generation = "depends" // Mark field that it depends on another field (on same ot other table)
)

type Databases struct {
	Databases map[string]*Database `json:"databases" yaml:"databases"`
}

type Database struct {
	Driver     string  `json:"driver" yaml:"driver"`
	Name       string  `json:"name" yaml:"name"` // Database name
	DSN        string  `json:"dsn" yaml:"dsn"`   // Database DSN
	TablesPath string  `json:"tables_path" yaml:"tablesPath"`
	Tables     []Table `json:"tables" yaml:"tables"`
}

type Table struct {
	Name   string           `json:"name" yaml:"name"`     // Table name
	Action Action           `json:"action" yaml:"action"` // Action (get from db or generate fake data)
	Count  int              `json:"count" yaml:"count"`   // Count rows for generate values
	Fields map[string]Field `json:"fields" yaml:"fields"`
	Fill   []map[string]any `json:"fill" yaml:"fill"`
}

func (t *Table) GetRowsCount() int {
	if t.Count <= 0 {
		if len(t.Fill) <= 0 {
			return 0
		} else {
			return len(t.Fill)
		}
	}

	return t.Count
}

func (t *Table) IsLoadFromDb() bool {
	return t.Action == ActionGet
}

type Field struct {
	Type       string     `json:"type" yaml:"type"`             // Type of field - string, email, hash, mac, ip and so on... See types constants
	Generation Generation `json:"generation" yaml:"generation"` // Generation strategy
	Plugins    []string   `json:"plugins" yaml:"plugins"`       // Plugins list for apply
	Depends    Dependence `json:"depends" yaml:"depends"`
	List       []string   `json:"list" yaml:"list"`
}

type Dependence struct {
	Foreign  []ForeignDependence  `json:"foreign" yaml:"foreign"`
	Internal []InternalDependence `json:"internal" yaml:"internal"`
}

type ForeignDependence struct {
	Db         string `json:"db" yaml:"db"`
	Table      string `json:"table" yaml:"table"`
	Field      string `json:"field" yaml:"field"`
	Expression string `json:"expression" yaml:"expression"`
}

type InternalDependence struct {
	Field      string `json:"field" yaml:"field"`
	Expression string `json:"expression" yaml:"expression"`
}

func NewDatabasesSchemaNotation(mainConf string) (*Databases, error) {
	cfg := &Databases{}
	dbData, readFileErr := os.ReadFile(mainConf)
	if readFileErr != nil {
		return nil, readFileErr
	}
	unmarshalErr := yaml.Unmarshal(dbData, cfg)
	if unmarshalErr != nil {
		return nil, unmarshalErr
	}

	for id, d := range cfg.Databases {
		if d.TablesPath != "" {
			d.TablesPath = strings.ReplaceAll(d.TablesPath, "$PWD", filepath.Dir(mainConf))

			walkErr := filepath.Walk(d.TablesPath, func(path string, info fs.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if info.IsDir() {
					return nil
				}
				tableData, tableFileReadErr := os.ReadFile(path)
				if tableFileReadErr != nil {
					return tableFileReadErr
				}
				type t struct {
					Tables []Table `json:"tables" yaml:"tables"`
				}

				tbl := &t{}
				tableUnmarshalErr := yaml.Unmarshal(tableData, tbl)
				if tableUnmarshalErr != nil {
					return tableUnmarshalErr
				}
				d.Tables = append(d.Tables, tbl.Tables...)

				return nil
			})
			if walkErr != nil {
				return nil, walkErr
			}
			cfg.Databases[id] = d
		}
	}

	return cfg, nil
}
