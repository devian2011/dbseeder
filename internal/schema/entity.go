package schema

import (
	"gopkg.in/yaml.v3"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
)

type Action string
type Generation string
type FieldType string

const (
	actionGenerate Action = "generate" // Generate list of values for insert to db
	actionGet      Action = "get"      // Get list of values from db

	generationTypeDb    Generation = "db"      // Data will be generated by DB for example auto_increment and so on
	generationTypeFaker Generation = "faker"   // Generate fake data
	generationTypeList  Generation = "list"    // Get data from defined list (property List of Field struct)
	generationDepends   Generation = "depends" // Mark field that it depends on another field (on same ot other table)
	generationFill      Generation = "fill"    // Mark field that it depends on fill table section
)

type Databases struct {
	Databases map[string]*Database `json:"databases" yaml:"databases"`
}

type Database struct {
	Driver     string  `json:"driver" yaml:"driver"`
	Name       string  `json:"name" yaml:"name"` // Database name
	DSN        string  `json:"dsn" yaml:"dsn"`   // Database DSN
	TablesPath string  `json:"tables_path" yaml:"tablesPath"`
	Tables     []Table `json:"tables" yaml:"tables"`
}

type Table struct {
	Name       string  `json:"name" yaml:"name"`     // Table name
	Action     Action  `json:"action" yaml:"action"` // Action (get from db or generate fake data)
	Count      string  `json:"count" yaml:"count"`   // Count rows for generate values
	Expression string  `json:"expression" yaml:"expression"`
	Fields     []Field `json:"fields" yaml:"fields"`
}

type Field struct {
	Name       string            `json:"name" yaml:"name"`             // Field name
	Type       FieldType         `json:"type" yaml:"type"`             // Type of field - string, email, hash, mac, ip and so on... See types constants
	Generation Generation        `json:"generation" yaml:"generation"` // Generation strategy
	Plugins    []string          `json:"plugins" yaml:"plugins"`       // Plugins list for apply
	Depends    Dependence        `json:"depends" yaml:"depends"`
	List       []string          `json:"list" yaml:"list"`
	Fill       map[string]string `json:"fill" yaml:"fill"`
	Range      struct {
		Begin string `json:"begin" yaml:"begin"`
		End   string `json:"end" yaml:"end"`
	} `json:"range" yaml:"range"`
}

type Dependence struct {
	Foreign  []ForeignDependence  `json:"foreign" yaml:"foreign"`
	Internal []InternalDependence `json:"internal" yaml:"internal"`
}

type ForeignDependence struct {
	Db    string `json:"db" yaml:"db"`
	Table string `json:"table" yaml:"table"`
	Field string `json:"field" yaml:"field"`
}

type InternalDependence struct {
	Db    string `json:"db" yaml:"db"`
	Table string `json:"table" yaml:"table"`
	Field string `json:"field" yaml:"field"`
}

func NewDatabasesSchemaNotation(mainConf string) (*Databases, error) {
	cfg := &Databases{}
	dbData, readFileErr := os.ReadFile(mainConf)
	if readFileErr != nil {
		return nil, readFileErr
	}
	unmarshalErr := yaml.Unmarshal(dbData, cfg)
	if unmarshalErr != nil {
		return nil, unmarshalErr
	}

	for id, d := range cfg.Databases {
		if d.TablesPath != "" {
			d.TablesPath = strings.ReplaceAll(d.TablesPath, "$PWD", filepath.Dir(mainConf))

			walkErr := filepath.Walk(d.TablesPath, func(path string, info fs.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if info.IsDir() {
					return nil
				}
				tableData, tableFileReadErr := os.ReadFile(path)
				if tableFileReadErr != nil {
					return tableFileReadErr
				}
				type t struct {
					Tables []Table `json:"tables" yaml:"tables"`
				}

				tbl := &t{}
				tableUnmarshalErr := yaml.Unmarshal(tableData, tbl)
				if tableUnmarshalErr != nil {
					return tableUnmarshalErr
				}
				d.Tables = append(d.Tables, tbl.Tables...)

				return nil
			})
			if walkErr != nil {
				return nil, walkErr
			}
			cfg.Databases[id] = d
		}
	}

	return cfg, nil
}
